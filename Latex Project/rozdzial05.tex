\chapter{Implementacja}

\section{Architektura}


\subsection{Struktura interfejsu REST}
% TO DO: Opis do poprawy (bo zmieniono układ tabel)
Poniższa tabela \ref{tab:rest1} prezentuje jakie zapytania mogą być odbierane przez aplikację serwerową. Z racji tego, że w aplikacji wykorzystywane są typy generyczne w klasach kontrolerach urządzeń i komponentów komputera (implementacja \ref{controller_genericDevice} uproszczono tabele by pokazać ogólną formę zapytań. Wszystkie zapytania posiadające "`devices"' w ścieżce umożliwiają alternatywne wywołanie zapytania na podstawie typu sprzętu. Ogólna zasada jest taka aby zastąpić "`devices"' odpowiadającemu typowi sprzętu: "`computers"', "`tablets"', "`other-devices"'. Powoduje to, że zapytanie wykonywane jest przez kontroler tej klasy, a co za tym idzie ma określony typ. Możliwe jest też wykonanie zapytania nie zmieniając ścieżki. Wtedy takie zapytanie wykonywane jest na ogólnym rodzaju sprzętu. Przykładowo "`devices/all"' pobiera wszystkie sprzęty nie zwracając uwagi na typ, natomiast "`computers/all"' pobiera tylko sprzętu typu "`Computer"'. Podobne rozwiązanie wykorzystano w komponentach komputera. Dotyczy to zapytań mających w ścieżce: "`component"'. Tutaj należy zamienić "`component"' na jeden z trzech dostępnych typów komponentu: "`rams"', "`cpus"', "`storages"'. W tym wypadku nie ma możliwości wywołania zapytania zawierającego "`component"'.

\begin{table}[H]\small
	\centering
\caption{Tabela prezentująca strukturę REST (cz.1)}
\label{tab:rest1}
\begin{tabularx}{\linewidth}{|X|l|p{3cm}|X|}
    \hline
    Ścieżka & Metoda & Parametry & Opis  \\
    \hline \hline
		/devices/all 	& GET & - & Pobranie danych sprzętów na podstawie określonego typu \\
		\hline
		/devices/{id} & GET & id urządzenia 	& Pobranie danych wszystkich sprzętów\\
    \hline
		/devices/{id}	& DELETE & id urządzenia 	& Usunięcie sprzętu\\
    \hline
		 /computers/update/id & PATCH & id sprzętu oraz zmienione dane sprzętu& aktualizacja danych komputera\\
		\hline
		 /tablets/update/id & PATCH & id sprzętu oraz zmienione dane sprzętu& aktualizacja danych tabletu\\
		\hline	 
		/other-device/update/id & PATCH & id sprzętu i zmienione dane sprzętu & aktualizacja danych innego urządzenia\\
		\hline
			 /computers/add & POST	& dane komputera 	& Dodanie nowego komputera	\\
    \hline
		/tablets/add & POST	& dane tabletu & Dodanie nowego urządzenia	\\
    \hline
		/other-device/add & POST	& dane innego urządzenia 	& Dodanie nowego urządzenia	\\
    \hline
		/devices/by-office& GET	& id biura 	& Pobranie danych sprzętu znajdujących się w biurze\\
    \hline
		/devices/all-ready-to-lottery& GET	& - & Pobranie danych sprzętów które są gotowe do losowania\\
    \hline
		
		/devices/all-ready-to-lottery-by-officeId/id& GET	& id biura & Pobranie danych sprzętów które są gotowe do losowania i znajdują się w danym biurze\\
    \hline
		/devices/set-ready-to-lottery/id 		& PUT	& id sprzętu & Ustawienie gotowości sprzętu do losowania	\\
    \hline
		/devices/set-not-ready-to-lottery/id & PUT	& id sprzętu & Ustawienie braku gotowości sprzętu do losowania	\\
    \hline
		/devices/set-ordered/id & PUT	& id sprzętu & Ustawienie statusu sprzętu na dostarczone	do pracownika	\\
    \hline
		/devices/set-not-ordered/id & PUT	& id sprzętu & Ustawienie statusu sprzętu na dostarczone	do pracownika	\\
    \hline
		/components/all 	& GET & - & Pobranie danych wszystkich procesorów, ram lub dysków pamięci \\
		\hline
		/components/{id} & GET & id komponentu 	& Pobranie danych procesora, ram lub dysku pamięci\\
    \hline
		/components/{id}	& DELETE & id komponentu 	& Usunięcie procesora, ram lub dysku pamięci\\
    \hline
		 /components/update/id & PUT & id sprzętu oraz zmienione dane sprzętu& aktualizacja danych komputera\\
		\hline
		 /offices/all	& GET & - & Pobranie wszystkich biur w systemie\\
		\hline
		/users/all	& GET & - & Pobranie wszystkich użytkowników w systemie\\
		\hline
		\end{tabularx}
		\end{table}

\begin{table}[H] \small
	\centering
\caption{Tabela prezentująca strukturę REST (cz.2)}
\label{tab:rest2}	 
\begin{tabularx}{\linewidth}{|X|l|p{3cm}|X|}\hline
    Ścieżka & Metoda & Parametry & Opis  \\
    \hline \hline
		 /users/all-standard	& GET & -& Pobranie wszystkich użytkowników z rolą pracownik w systemie\\
		\hline
		 /users/id & GET & - & Pobranie użytkownika\\
		\hline
		 /users/id & DELETE & - & Usunięcie użytkownika\\
		\hline
		 /participation/add & POST & id użytkownika oraz id urządzenia & Dodanie uczestnictwa użytkownika w loterii do wybranego sprzętu\\
		\hline
		 /participation/all& POST & - & Wyświetlenie wszystkich uczestników dla każdego sprzętu\\
		\hline
		 /participation/id & DELETE & - & Usunięcie uczestnictwa o zadanym id\\
		\hline
		 /participation/delete-by-user\_id-and-device\_id& DELETE & id użytkownika i id sprzętu & Usunięcie uczestnictwa spełniającego zadane kryteria\\
		\hline
		 /participation/all-wins& GET & - & Wyświetlenie wszystkich zwycięskich uczestników\\
		\hline
		 /participation/user-lottery-history/id & GET& id użytkownika & Wyświetlenie historii uczestnictwa użytkownika o zadanym id\\
		\hline
		 /participation/user-win-history/id & GET& id użytkownika & Wyświetlenie historii zwycięstw użytkownika o zadanym id\\
		\hline
		 /participation/user-lose-history/id & GET& id użytkownika & Wyświetlenie historii porażek użytkownika o zadanym id\\
		\hline
		 /participation/user-pending-lottery/id & GET& id użytkownika & Wyświetlenie uczestnictwa które czeka na losowanie\\
		\hline
		 /participation/device-participation/id& GET& id urządzenia & Wyświetlenie wszystkich użytkowników zapisanych na losowaniu urządzenia o zadanym id\\
		\hline
		 /participation/check-if-user-in-lottery& GET& id urządzenia oraz id użytkownika& Sprawdzenie czy użytkownik bierze udział w losowaniu\\
		\hline
		 /participation/select-random-winner/id& GET& id urządzenia& Losowanie zwycięzcy loterii dla urządzenia o zadanym id\\
		\hline
\end{tabularx}
\end{table}



\section{Aplikacja serwerowa}
Do zarządzania danymi wykorzystywana jest aplikacja serwerowa. Przetwarza ona żądania aplikacji klienckiej. Dostarcza ona funkcjonalność uwierzytelniania i autoryzacji. W wyniku zapytań wysłanych przez aplikację kliencką wyświetlane są w aplikacji odpowiednie dane. Możliwe jest też dodawanie i usuwanie odpowiednich rekordów. Implementacja odbywa się z wykorzystywaniem języka Java z frameworkami Spring oraz Hibernate \ref{tab:zestawienie_narzędzi} Graficzną reprezentacje struktury projektu aplikacji serwerowej pokazano na rysunku \ref{backend_struktura:label}

\subsection{Struktura projektu}
Ścieżka pakietowa wykorzystana jest odwróconą ścieżką domenową Politechniki Wrocławskiej oraz nazwy projektu: pl.edu.pwr.computermanagamenttool. Następnie pakiety które są dołączone do tej ścieżki odpowiadają funkcjom które pełnią klasy. Wyróżnia się tutaj pakiety:
\begin{itemize}
\item pl.edu.pwr.computermanagementtool - pakiet ogólny przechowywujący pozostałe pakiety. Klasa ComputerManagementToolApplication posiada metodę Main odpowiedzialną za uruchomienie aplikacji. Klasa JacksonConfig jest konfiguracją odpowiedzialną za serializacje formatu JSON. Natomiast klasa PasswordEncoderUtil jest odpowiedzialna za szyfrowanie haseł użytkowników korzystających z systemu.
\item controller - pakiet przechowujący w sobie klasy kontrolerów odpowiedzialne za wykonywanie zapytań aplikacji za pomocą interfejsu REST
\item dto - pakiet który jest odpowiedzialny za przechowywanie klas służących do przechowywania danych i ułatwiania ich przesyłania między różnymi częściami systemu. Wykorzystywany jest w klasach kontrolera.
\item entity - pakiet przechowujący definicje encji reprezentowanych w bazie danych
\item repository - pakiet przechowujący repozytoria służące do komunikacji z bazą danych.
\item service - pakiet przechowujący serwisy które są odpowiedzialne za warstwę logiki biznesowej w systemie
\end{itemize}


\begin{figure}[htb]
  \centering
	\begin{tabular}{@{}lll@{}}
	a) & b) & c) \\
  \includegraphics[width=0.3\textwidth]{rys05/backend/ogolne.pdf} & 
	\includegraphics[width=0.3\textwidth]{rys05/backend/controller.pdf} &
	\includegraphics[width=0.3\textwidth]{rys05/backend/dto.pdf} \\

	d) & e) & f) \\
	\includegraphics[width=0.3\textwidth]{rys05/backend/entity.pdf} &
	\includegraphics[width=0.3\textwidth]{rys05/backend/repository.pdf} &
	\includegraphics[width=0.3\textwidth]{rys05/backend/service.pdf}
	\end{tabular}
  \caption{Struktura projektu a) ogólna struktura, b) kontrolery, c) data transfer object, d) encje, e) repozytoria, f) serwisy}
  \label{backend_struktura:label}
\end{figure}

\newpage
\subsection{Fragmenty implementacji}
\subsubsection {Fragment kodu klas encji wykorzystującej schemat dziedziczenia}

\begin{lstlisting}[language=Java, style=JavaStyle, caption={Klasa nadrzędna reprezentująca rdzeń sprzętu: DeviceCore}, label={entity_deviceCore}]
@Entity
@Table(name = "device_core")
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class DeviceCore {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    @Column(name = "id", nullable = false)
    private Integer id;

    @Column(name = "device_type", length = 50)
    private String deviceType;

    @Column(name = "device_name", length = 50)
    private String deviceName;
		
		// Pozostała część klasy

\end{lstlisting}
W linii 3 listingu klasy DeviceCore \ref{entity_deviceCore} określono schemat dziedziczenia TABLE\_PER\_CLASS. O sposobie dziedziczenia napisano w podrozdziale \ref{dzedziczenie_hibernate:label}. Linia 3 określa strategie generowania klucza. Hibernate tworzy wtedy specjalną tabelę w bazie danych która odpowiedzialna jest za przechowywanie unikalnych kluczy głownych dla encji sprzętu w aplikacji. W listingu kodu \ref{entity_computer} nie trzeba wtedy definować klucza.

\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa potomna: Computer, reprezentująca komputer}, label={entity_computer}]
@Entity
@Table(name = "computer")
public class Computer extends DeviceCore{

    public static final String DEVICE_TYPE = "COMPUTER";
    @Column(name = "serial_number", length = 50)
    private String serialNumber;

    @Column(name = "operating_system", length = 50)
    private String operatingSystem;

    @Column(name = "battery_life", length = 50)
    private String batteryLife;
		
		// Pozostała część klasy
\end{lstlisting}
W linii 3 określone zostało dziedziczenie po klasie nadrzędnej reprezentującej rdzeń sprzętu. Pola które należy określić w tej klasie są unikalnymi polami tabeli computer. W linii 4 istnieje statyczna zmienna DEVICE\_TYPE która pomaga określić jakiego rodzaju dany sprzęt. Wykorzystywane jest to w aplikacji klienckiej.


\subsubsection{Przykład kodu repozytorium dla urządzeń dziedziczącym po rdzeniu sprzętu}
Repozytorium sprzętu komputerowego zostało napisane z użyciem wyrażeń generycznych. Wykorzystanie ich przyczynia się do uproszczenia kodu oraz łatwiejszej jego rozbudowy.

\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Generyczne repozytorium sprzętu komputerowego:  GenericDeviceRepository}, label={repo_genericDevice}]
@NoRepositoryBean
public interface GenericDeviceRepository<T extends DeviceCore> extends JpaRepository<T, Integer> {
    
    List<T> findAllByReadyToLotteryIsTrue();
    List<T> findAllByOfficeId(int officeId);
}
\end{lstlisting}

W lini 1 adnotacja @NoRepositoryBean jest używana do oznaczenia interfejsów które nie mają mieć swojej instancji. Oznacza to, że nie jest on przeznaczony do utworzenia instancji repozytorium w trakcie uruchomiania aplikacji. W linii 4 i 5 poprzez zdefiniowanie metody możliwe jest wykonanie konkretego zapytania SQL do bazy danych. Z racji, że klasy sprzętu komputerowego mają zbliżone funkcjonalności nie trzeba dostarczać tych samych interfejsów we wszystkich repozytoriach tylko zastosować schemat dziedziczenia.

\subsubsection{Fragmenty implementacji klasy kontrolerów sprzętu}

\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa nadrzędna kontrolera sprzętu: GenericDeviceController}, label={controller_genericDevice}]
public abstract class GenericDeviceController<T extends DeviceCore> {

    protected final GenericDeviceService<T> genericDeviceService;
    protected final GenericDeviceRepository<T> genericRepository;

    protected GenericDeviceController(GenericDeviceService<T> genericDeviceService, GenericDeviceRepository<T> genericRepository) {
        this.genericDeviceService = genericDeviceService;
        this.genericRepository = genericRepository;
    }

    @GetMapping("/{id}")
    @CrossOrigin(origins = "*")
    T getOneBasicDevice(@PathVariable int id){
        return genericDeviceService.getDeviceById(id);
    }

    @GetMapping("/all")
    @CrossOrigin(origins = "*")
    List<T> getAllBasicDevices(){
        return genericDeviceService.getAllDevices();
    }

    @GetMapping("/all-ready-to-lottery")
    @CrossOrigin(origins = "*")
    List<T> getAllReadyToLotteryDevice(){
        return genericDeviceService.getAllReadyToLotteryDevices();
    }
		
		// Pozostała część klasy
		
		@PutMapping("/set-ready-to-lottery/{id}")
    @CrossOrigin(origins = "*")
    public ResponseEntity<T> setReadyToLottery(@PathVariable int id){
        try{
            T updatedBasicDevice = genericDeviceService.setReadyToLottery(id);
            return new ResponseEntity<>(updatedBasicDevice, HttpStatus.OK);
        } catch (RuntimeException e){
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }
		
		// Pozostała część klasy
		
\end{lstlisting}

Kontrolery pełnią istotną funkcje w systemie. Umożliwiają one definiowanie zapytań REST które będą wysyłane do serwera. Wykorzystując abstrakcje oraz wyrażenia generyczne możliwe jest wykonanie niektórych requestów bez konieczności ich implementacji w klasach potomnych.


\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa potomna reprezentująca ogólną postać sprzętu}, label={controller_device}]
@RestController
@RequestMapping("/devices")
public class DeviceCoreController extends GenericDeviceController<DeviceCore>{

    protected DeviceCoreController(DeviceCoreService deviceCoreService, GenericDeviceRepository<DeviceCore> genericRepository) {
        super(deviceCoreService, genericRepository);
    }
}
\end{lstlisting}

Powyższa klasa w listingu kodu \ref{controller_device} nie posiada własnych metod. Umożliwia jednak wykonywanie ogólnych operacji dotyczących sprzętu. Możliwe jest między innymi pobranie informacji dotyczące sprzętu bez względu na jego typ co idealanie obrazuje test **referencja do zapytania w postmanie**


\subsubsection{Fragmenty implementacji klas serwisów sprzętu}


\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa nadrzędna serwisu sprzętu GenericDeviceService}, label={service_tablet}]

public abstract class GenericDeviceService<T extends DeviceCore> {

    protected final GenericDeviceRepository<T> genericDeviceRepository;
    protected final OfficeRepository officeRepository;

    public GenericDeviceService(GenericDeviceRepository<T> genericRepository, OfficeRepository officeRepository) {
        this.genericDeviceRepository = genericRepository;
        this.officeRepository = officeRepository;
    }

    public T getDeviceById(int id) {
        Optional<T> basicDeviceOptional = genericDeviceRepository.findById(id);
        return basicDeviceOptional.orElseThrow(()-> new RuntimeException("Device not found with id: " + id));
    }

    public List<T> getAllDevices() {
        return genericDeviceRepository.findAll();
    }
		// Pozostała część klasy

protected DeviceCore addDevice(Class<? extends DeviceCore> deviceClass, String deviceName, Double price, String description, Integer age, Boolean readyToSell, Integer officeId) {

        if(officeId == null){
            throw new RuntimeException("Office required");
        }
        Optional<Office> officeOptional = officeRepository.findById(officeId);
        Office office = officeOptional.orElseThrow(() -> new RuntimeException("Office not found with id: " + officeId));

        DeviceCore deviceCore;
        try {
            deviceCore = deviceClass.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            throw new RuntimeException("Error creating device", e);
        }

        deviceCore.setDeviceName(deviceName);
        deviceCore.setPrice(price);
        deviceCore.setDescription(description);
        deviceCore.setAge(age);
        deviceCore.setReadyToSell(readyToSell);
        deviceCore.setOffice(office);

        return deviceCore;
    }
		
		// Pozostała część klasy

\end{lstlisting}
Serwisy są odpowiedzialne za warstwe logiki biznesowej systemu. W linii 12 widnieje metoda która pozwala na pobranie sprzętu. W linii 17 natomiast jest możliwe pobranie wszystkich sprzętów. Odbywa się to przy pomocy parametryzowanych typów danych T. Metoda zdefiniowana w linii 22 pozwala uprościć dodawanie sprzętu, implementując część logiki ustawiając parametry charakterystyczne dla rdzenia sprzętu. Jednak aby utworzyć odpowiedni typ niezbędne jest określenie jakiego typu będzie dodawane urządzenie, Dlatego w linii 22 metoda jako parametr przyjmuje Class<? extends DeviceCore> który oznacza typ aplikacji. Tak zdefiniowana metoda może zostać użyta do dodania sprzętu w kalsach potomnych co pokazano w listingu \ref{service_tablet}

\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa potomna serwisu tabletu: TabletService }, label={service_tablet}]

@Service
public class TabletService extends GenericDeviceService<Tablet>{

    public TabletService(TabletRepository tabletRepository, OfficeRepository officeRepository){
        super(tabletRepository, officeRepository);
    }

    public Tablet addTablet(String deviceName, Double price, String description,
                            Integer age, String officeAddress,
                            String screenSize, String operatingSystem, String batteryLife){

        Tablet tablet = (Tablet) addDevice(Tablet.class, deviceName, price, description,
                                                                age, officeAddress);

        tablet.setScreenSize(screenSize);
        tablet.setOperatingSystem(operatingSystem);
        tablet.setDeviceType(Tablet.DEVICE_TYPE);
        tablet.setBatteryLife(batteryLife);

        return genericDeviceRepository.save(tablet);
    }
		// Pozostała część klasy
\end{lstlisting}

Serwis klasy TabletService dziedziczy i parametryzuje metody klasy GenericDeviceService. Wykorzystuje on w linii 13 metodę klasy nadrzędnej co uprasza implementacje metody dodającej sprzęt(linia 9)



\section {Aplikacja kliencka}
Aplikacja kliencka jest aplikacją internetową dostarczającą przyjazny interfejs użytkownika. W aplikacji klienckiej napisanej w języku JavaScript z wykorzystaniem biblioteki React (tabela \ref{tab:zestawienie_narzędzi}) istnieją zdefiniowane zapytania REST do aplikacji serwerowej. Wykorzystując te zapytania na widoku widocznym dla użytkownika zostają podjęte specjalne akcje które ten widok aktualizują. Formularze pokazywane są w takiej formie, że po kliknięciu odpowiedniego przycisku ukazuje się formularz na danym widoku. Zestawienie widoków, ścieżek i roli pokazano w tabeli \ref{tab:zestawienie_widokow}

\subsection{Struktura projektu}
Ogólna struktura projektu została stworzona przez wywołanie komendy tworzącej aplikacje Reacta: npx create-react-app frontend. Następnie utworzono folder components który w sobie zawiera foldery przechowujące pliki JavaScript na podstawie pełnionych funkcji w projekcie. Foldery i odpowiadające im funkcje: 
\begin {itemize}
\item \textbf{auth} przechowuje pliki odpowiedzialne za obsługę i stylizacje widoków logowania i rejestracji
	\begin{itemize}
	\item Login.js - skrypt odpowiedzialny za widok i funkcjonalność logowania
	\item Register.js - skrypt odpowiedzialny za widok i funkcjonalność rejestracji
	\item Login.css - arkusz styli odpowiedzialny za stylizacje widoków logowania i rejestracji
	\end{itemize}
\item \textbf{bar} przechowuje skrypty odpowiedzialne za paski nawigacyjne poszczególnych widoków.
	\begin{itemize}
	\item AdminHomeBar.js - skrypt odpowiedzialny za pasek nawigacyjny na widoku domowym administratora: Home.js
	\item ComputerComponentsBar.js -skrypt odpowiedzialny za pasek nawigacyjny dla widoku komponentów: ComputerComponents.js
	\item ManageUserBar.js -skrypt odpowiedzialny za pasek nawigacyjny widoku zarządzania użytkownikami: Users.js
	\item UserHomeBar.js - skrypt odpowiedzialny za pasek nawigacyjny na widoku domowym pracownika: Home.js
	\item UserLotteryHistory -skrypt odpowiedzialny za pasek nawigacyjnym na widoku historii loterii użytkownika: UserLotteryHistory.js
	\item UsersInLottery.js -skrypt odpowiedzialny za pasek nawigacyjny na widoku użytkowników biorących udział w loterii: UsersInLottery.js
	\end{itemize}
\item \textbf{computer\_components} przechowuje skrypty formularzy komponentów komputera które mogą dodawać lub modyfikować te komponenty
	\begin{itemize}
	\item CpuForm.js - formularz procesora
	\item RamForm.js - formularz pamięci RAM
	\item StorageForm.js - formularz pamięcu dyskowej
	\end{itemize}
\item \textbf{device\_form} przechowuje skrypty oraz arkusz styli odpowiedzialne za logikę formularzy dodawania, modyfikacji urządzeń
	\begin{itemize}
	\item AddNewFormPopup.js - formularz umożliwiający wybór formularza który dodaje komputer, tablet, lub inne urządzenie
	\item ComputerForm.js -formularz komputera
	\item DeviceForm.css - arkusz styli odpowiedzialny za stylizacje formularzy
	\item FormPopup.js - skrypt odpowiedzialny za logikę i wybór rodzaju formularza(dodawanie, modyfikacja, informacje) urządzenia.
	\item OtherDeviceForm - formularz innego urządzenia
	\item TabletForm.js - formularz tabletu
	\end{itemize}
\item \textbf{view} przechowuje w sobie skrypty oraz arkusz styli odpowiedzialne za widoki aplikacji
	\begin{itemize}
	\item ComputerComponets.js -widok dostępny tylko dla administratora. Zawiera w sobie informacje o komponentach komputera w postaci tabeli
	\item Home.css - arkusz styli odpowiedzialny za stylizacje widoków
	\item Home.js - widok strony domowej, ma w sobie dwa warianty: Administartora i Pracownika
	\item UserLotteryHistory.js - widok hostorii loterii użytkownika o zadanym ID. Dostępny dla pracownika i administratora.
	\item Users.js - widok pracowników zarejestrowanych w systemie. Dostępny tylko dla administratora
	\item UsersInLottery - widok pracowników biorących udział w loterii danego sprzętu. Dostępny tylko dal administratora.
	\end{itemize}
\end{itemize}

Równolegle do folderu components w folderze src istnieją jeszcze dwa skrypty które są niezbędne do funkcjonowania aplikacji.
\begin{itemize}
	\item App.js zawiera w sobie scieżki url pod którymi dostępne są poszczególne widoki
	\item index.js - funkcja główna programu
\end{itemize}

Strukturę projektu pokazano na Rysunku \ref{frontend_struktura:label}


\begin{table}[htb] \small
	\centering
\caption{Zestawienie ścieżek url dostępnych w aplikacji klienckiej}
\label{tab:zestawienie_widokow}
\begin{tabularx}{\linewidth}{|X|X|X|X|}
    \hline
    Ścieżka & Widok & Skrypt & Rola\\
    \hline \hline
    /auth/login & Logowanie &  Login.js & Przed nadaniem roli\\
    \hline
    /auth/register & Rejestracja & Register.js & Przed nadaniem roli\\
    \hline
    /home & Strona domowa z tabelą sprzętów & Home.js & Administrator lub Pracownik\\
    \hline
    /users & Tabela pracowników & Users.js & Administrator\\
    \hline
		/components & Tabela komponentów komputera& ComputerComponents.js & Administrator\\
    \hline
		/users-in-lottery & Tabela użytkowników biorących udział w loterii& UsersInLottery.js & Administrator lub Pracownik\\
    \hline
		/users-lottery-history & Tabela zawierająca historię loteri & UsersLotteryHistory.js & Administatro lub Pracownik\\

    \hline
\end{tabularx}
\end{table}


\begin{figure}[htb]
  \centering
	\begin{tabular}{@{}lll@{}}
	a) & b) & c) \\
  \includegraphics[width=0.3\textwidth]{rys05/frontend/frontend.pdf} & 
	\includegraphics[width=0.3\textwidth]{rys05/frontend/auth.pdf} &
	\includegraphics[width=0.3\textwidth]{rys05/frontend/bar.pdf} \\

	d) & e) & f) \\
	\includegraphics[width=0.3\textwidth]{rys05/frontend/components.pdf} &
	\includegraphics[width=0.3\textwidth]{rys05/frontend/deviceform.pdf} &
	\includegraphics[width=0.3\textwidth]{rys05/frontend/view.pdf}
	\end{tabular}
  \caption{Struktura projektu a) ogólna struktura, b) Logowanie i rejestracja, c) pasek nawigacyjny, d) formularze komponentów, e) formularze sprzętów, f) widoki stron}
  \label{frontend_struktura:label}
\end{figure}



\subsection{Fragmenty implementacji}
	\subsubsection{Ścieżki url dla widoków aplikacji}
	

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle,  caption={Zdefiniowane ścieżki url widoków systemu }, label={app_frontend:label}]
	
	const App = () => {
    return (
        <Router>
            <Routes>
                <Route path="/auth/login" element={<Login />} />
                <Route path="/auth/register" element={<Register />} />
                <Route path="/home" element={<Home />} />
                <Route path="/" element={<Navigate to="/auth/login" />} />
                <Route path="/auth/*" element={<Navigate to="/auth/login" />} />
                <Route path="/users" element={<Users/>}/>
                <Route path="/components" element={<ComputerComponents/>}/>
                <Route path="/users-in-lottery" element={<UsersInLottery/>}/>
                <Route path="/user-lottery-history" element={<UserLotteryHistory/>}/>
            </Routes>
        </Router>
    );
};
	
\end{lstlisting}
Powyższy listing kodu \ref{app_frontend:label} definiuje ścieżki url pod którymi dostępne są poszczególne widoki~\ref{tab:zestawienie_widokow}


\subsubsection{Sparametryzowany formularz urządzenia}

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle,  caption={Obsługa formularzy}, label={render_data:label}]

function FormPopup(props){
    
 const {setTrigger, formType, deviceType, deviceId} = props;
    
  return (props.trigger) ? (
    <div className="popup">
      <div>
         {deviceType === 'COMPUTER' && <ComputerForm setTrigger={props.setTrigger} formType={formType} deviceId={deviceId}/>}
         {deviceType === 'TABLET' && <TabletForm setTrigger={props.setTrigger} formType={formType} deviceId={deviceId}/>}
         {deviceType === 'OTHER' && <OtherDeviceForm setTrigger={props.setTrigger}  formType={formType} deviceId={deviceId} />}
         {props.children}
      </div>
    </div>
 ) : "";
}

export default FormPopup
										
\end{lstlisting}

Powyższy listing kodu \ref{render_data:label} dla skryptu FormPopup.js  służy do dodawania różnych rodzajów formularza sprzętów z różnymi wariantami. Przyjmuje 4 argumenty. Przekazywanie tych parametrów odbywa się w linii 4 z wykorzystaniem "`props"'. Zmienna deviceType odpowiada dla jakiego urządzenia dotyczy formularz. Może on dotyczyć komputera, tableta lub innego urządzenia co pokazano w liniach 9-11. Zmienna setTrigger jest odpowiedzialna za to czy formularz jest aktualnie wyświetlany nad widokiem. Zmienna formType dotyczy wariant formularza. Istnieją 3 warianty jednego formularza i dotyczą one kolejno: dodawania nowego sprzętu, modyfikacji sprzętu oraz wyświetlania informacji o sprzęcie. Warianty formularza pokazano rysunku **referencja do rysunku**. Tak stworzona funkcja umożliwia zarządzanie formularzami które zostały zdefiniowane w plikach ComputerForm.js, TabletForm.js oraz OtherDeviceForm.js.

\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle,  caption={Przykładowe zapytanie do serwera dla formularza komputera}, label={addComputer:label}]

const handleAddComputer = async (e) =>{

        try{
            const compData ={
                "deviceName" : formData.deviceName,
                "price" : formData.price,
                "description" : formData.description,
                "age" : formData.age,
                "officeAddress" : formData.office,
                "serialNumber" : formData.serialNumber,
                "model" : formData.model,
                "operatingSystem" : formData.model,
                "batteryLife" : formData.batteryLife,
                "cpuName" : formData.cpu,
                "storageName" : formData.storage,
                "ramName" : formData.ram
            };

            const response = await axios.post('http://localhost:8080/computers/add', compData, {

            });

        }catch (error){
            console.error('Bład dodawania komputera', error)
        }

\end{lstlisting}

Powyższy listing kodu \ref{addComputer:label} ukazuje w jaki sposób aplikacje kliencka komunikuje się z serwerem. Po podaniu odpowiednich danych w formularzu i kliknięciu przycisku następuje wysłanie żądania typu POST do serwera które dodaje nowy komputer. 


\subsubsection{Widoki aplikacji}
%TODO opisy scieżek w aplikacji


\subsection{Instrukcja użytkowania}
\subsubsection{Logowanie i rejestracja}

\subsubsection{Administrator}
\subsubsection{Pracownik}



