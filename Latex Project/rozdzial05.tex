\chapter{Implementacja}

\section{Architektura}


\subsection{Struktura interfejsu REST}
% TO DO: Opis do poprawy (bo zmieniono układ tabel)
% DONE
Tabele \ref{tab:rest1} oraz \ref{tab:rest2} prezentują jakie zapytania mogą być odbierane przez aplikację serwerową. Z~racji tego, że w aplikacji wykorzystywane są typy generyczne w klasach kontrolerach urządzeń i komponentów komputera (implementacja \ref{controller_genericDevice}) uproszczono tabele by pokazać ogólną formę zapytań. Wszystkie zapytania posiadające "`\texttt{devices}"' w ścieżce umożliwiają alternatywne wywołanie zapytania na podstawie typu sprzętu. Ogólna zasada jest taka aby zastąpić "`\texttt{devices}"' odpowiadającemu typowi sprzętu: "`\texttt{computers}"', "`\texttt{tablets}"', "`\texttt{other-devices}"'. Powoduje to, że zapytanie wykonywane jest przez kontroler tej klasy, a co za tym idzie ma określony typ. Możliwe jest też wykonanie zapytania nie zmieniając ścieżki. Wtedy takie zapytanie wykonywane jest na ogólnym rodzaju sprzętu. Przykładowo "`\texttt{devices/all}"' pobiera wszystkie sprzęty nie zwracając uwagi na typ, natomiast "`\texttt{computers/all}"' pobiera tylko sprzętu typu "`\texttt{Computer}"'. Podobne rozwiązanie wykorzystano w komponentach komputera. Dotyczy to zapytań mających w ścieżce: "`\texttt{component}"'. Tutaj należy zamienić "`\texttt{component}"' na jeden z trzech dostępnych typów komponentu: "`\texttt{rams}"', "`\texttt{cpus}"', "`\texttt{storages}"'. W tym wypadku nie ma możliwości wywołania zapytania zawierającego "`\texttt{component}"'.

\begin{table}[H]\small
	\centering
\caption{Tabela prezentująca strukturę REST (cz.1)}
\label{tab:rest1}
\begin{tabularx}{\linewidth}{|X|l|p{3cm}|X|}
    \hline
    Ścieżka & Metoda & Parametry & Opis  \\
    \hline \hline
		/devices/all 	& GET & - & Pobranie danych sprzętów na podstawie określonego typu \\
		\hline
		/devices/{id} & GET & id urządzenia 	& Pobranie danych wszystkich sprzętów\\
    \hline
		/devices/{id}	& DELETE & id urządzenia 	& Usunięcie sprzętu\\
    \hline
		 /computers/update/id & PATCH & id sprzętu oraz zmienione dane sprzętu& aktualizacja danych komputera\\
		\hline
		 /tablets/update/id & PATCH & id sprzętu oraz zmienione dane sprzętu& aktualizacja danych tabletu\\
		\hline	 
		/other-device/update/id & PATCH & id sprzętu i zmienione dane sprzętu & aktualizacja danych innego urządzenia\\
		\hline
			 /computers/add & POST	& dane komputera 	& Dodanie nowego komputera	\\
    \hline
		/tablets/add & POST	& dane tabletu & Dodanie nowego urządzenia	\\
    \hline
		/other-device/add & POST	& dane innego urządzenia 	& Dodanie nowego urządzenia	\\
    \hline
		/devices/by-office& GET	& id biura 	& Pobranie danych sprzętu znajdujących się w biurze\\
    \hline
		/devices/all-ready-to-lottery& GET	& - & Pobranie danych sprzętów które są gotowe do losowania\\
    \hline
		
		/devices/all-ready-to-lottery-by-officeId/id& GET	& id biura & Pobranie danych sprzętów które są gotowe do losowania i znajdują się w danym biurze\\
    \hline
		/devices/set-ready-to-lottery/id 		& PUT	& id sprzętu & Ustawienie gotowości sprzętu do losowania	\\
    \hline
		/devices/set-not-ready-to-lottery/id & PUT	& id sprzętu & Ustawienie braku gotowości sprzętu do losowania	\\
    \hline
		/devices/set-ordered/id & PUT	& id sprzętu & Ustawienie statusu sprzętu na dostarczone	do pracownika	\\
    \hline
		/devices/set-not-ordered/id & PUT	& id sprzętu & Ustawienie statusu sprzętu na dostarczone	do pracownika	\\
    \hline
		/components/all 	& GET & - & Pobranie danych wszystkich procesorów, ram lub dysków pamięci \\
		\hline
		/components/{id} & GET & id komponentu 	& Pobranie danych procesora, ram lub dysku pamięci\\
    \hline
		/components/{id}	& DELETE & id komponentu 	& Usunięcie procesora, ram lub dysku pamięci\\
    \hline
		 /components/update/id & PUT & id sprzętu oraz zmienione dane sprzętu& aktualizacja danych komputera\\
		\hline
		 /offices/all	& GET & - & Pobranie wszystkich biur w systemie\\
		\hline
		/users/all	& GET & - & Pobranie wszystkich użytkowników w systemie\\
		\hline
		\end{tabularx}
		\end{table}

\begin{table}[H] \small
	\centering
\caption{Tabela prezentująca strukturę REST (cz.2)}
\label{tab:rest2}	 
\begin{tabularx}{\linewidth}{|X|l|p{3cm}|X|}\hline
    Ścieżka & Metoda & Parametry & Opis  \\
    \hline \hline
		 /users/all-standard	& GET & --- & Pobranie wszystkich użytkowników z rolą pracownik w systemie\\
		\hline
		 /users/id & GET & --- & Pobranie użytkownika\\
		\hline
		 /users/id & DELETE & --- & Usunięcie użytkownika\\
		\hline
		 /participation/add & POST & id użytkownika oraz id urządzenia & Dodanie uczestnictwa użytkownika w loterii do wybranego sprzętu\\
		\hline
		 /participation/all& POST & --- & Wyświetlenie wszystkich uczestników dla każdego sprzętu\\
		\hline
		 /participation/id & DELETE & --- & Usunięcie uczestnictwa o zadanym id\\
		\hline
		 /participation/delete-by-user\_id-and-device\_id& DELETE & id użytkownika i id sprzętu & Usunięcie uczestnictwa spełniającego zadane kryteria\\
		\hline
		 /participation/all-wins& GET & --- & Wyświetlenie wszystkich zwycięskich uczestników\\
		\hline
		 /participation/user-lottery-history/id & GET& id użytkownika & Wyświetlenie historii uczestnictwa użytkownika o zadanym id\\
		\hline
		 /participation/user-win-history/id & GET& id użytkownika & Wyświetlenie historii zwycięstw użytkownika o zadanym id\\
		\hline
		 /participation/user-lose-history/id & GET& id użytkownika & Wyświetlenie historii porażek użytkownika o zadanym id\\
		\hline
		 /participation/user-pending-lottery/id & GET& id użytkownika & Wyświetlenie uczestnictwa które czeka na losowanie\\
		\hline
		 /participation/device-participation/id& GET& id urządzenia & Wyświetlenie wszystkich użytkowników zapisanych na losowaniu urządzenia o zadanym id\\
		\hline
		 /participation/check-if-user-in-lottery& GET& id urządzenia oraz id użytkownika& Sprawdzenie czy użytkownik bierze udział w losowaniu\\
		\hline
		 /participation/select-random-winner/id& GET& id urządzenia& Losowanie zwycięzcy loterii dla urządzenia o zadanym id\\
		\hline
\end{tabularx}
\end{table}



\section{Aplikacja serwerowa}
Do zarządzania danymi wykorzystywana jest aplikacja serwerowa. Przetwarza ona żądania aplikacji klienckiej. Dostarcza ona funkcjonalność uwierzytelniania i autoryzacji. W wyniku zapytań wysłanych przez aplikację kliencką wyświetlane są w aplikacji odpowiednie dane. Możliwe jest też dodawanie i usuwanie odpowiednich rekordów. Implementacja odbywa się z wykorzystywaniem języka Java z frameworkami Spring oraz Hibernate \ref{tab:zestawienie_narzędzi} Graficzną reprezentacje struktury projektu aplikacji serwerowej pokazano na rysunku \ref{backend_struktura:label}

\subsection{Struktura projektu}
Ścieżka pakietowa wykorzystana jest odwróconą ścieżką domenową Politechniki Wrocławskiej oraz nazwy projektu: \texttt{pl.edu.pwr.computermanagamenttool}. Następnie pakiety które są dołączone do tej ścieżki odpowiadają funkcjom które pełnią klasy. Wyróżnia się tutaj pakiety:
\begin{itemize} %DONE wykorzystanie czcionki maszynowej 
\item \texttt{pl.edu.pwr.computermanagementtool} - pakiet ogólny przechowywujący pozostałe pakiety. Klasa \texttt{ComputerManagementToolApplication} posiada metodę \texttt{Main}odpowiedzialną za uruchomienie aplikacji. Klasa \texttt{JacksonConfig} jest konfiguracją odpowiedzialną za serializację formatu JSON. Natomiast klasa \texttt{PasswordEncoderUtil} jest odpowiedzialna za szyfrowanie haseł użytkowników korzystających z systemu,
\item \texttt{controller} -- pakiet przechowujący w sobie klasy kontrolerów odpowiedzialne za wykonywanie zapytań aplikacji za pomocą interfejsu REST,
\item \texttt{dto} -- pakiet który jest odpowiedzialny za przechowywanie klas służących do przechowywania danych i ułatwiania ich przesyłania między różnymi częściami systemu. Wykorzystywany jest w klasach kontrolera,
\item \texttt{entity} -- pakiet przechowujący definicje encji reprezentowanych w bazie danych,
\item \texttt{repository} -- pakiet przechowujący repozytoria służące do komunikacji z bazą danych,
\item \texttt{service} -- pakiet przechowujący serwisy które są odpowiedzialne za warstwę logiki biznesowej w systemie.
\end{itemize}


\begin{figure}[htb]
  \centering
	\begin{tabular}{@{}lll@{}}
	a) & b) & c) \\
  \vtop{\vskip-2ex\hbox{\includegraphics[width=0.33\textwidth]{rys05/backend/ogolne.pdf}}} & 
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.33\textwidth]{rys05/backend/controller.pdf}}} &
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.33\textwidth]{rys05/backend/dto.pdf}}} \\

	d) & e) & f) \\
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.33\textwidth]{rys05/backend/entity.pdf}}} &
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.33\textwidth]{rys05/backend/repository.pdf}}} &
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.33\textwidth]{rys05/backend/service.pdf}}}
	\end{tabular}
  \caption{Struktura projektu: a) ogólna struktura, b) kontrolery, c) dto, d) encje, e) repozytoria, f) serwisy}
  \label{backend_struktura:label}
\end{figure}

\subsection{Fragmenty implementacji}
\subsubsection {Fragment kodu klas encji wykorzystującej schemat dziedziczenia}
Na listingu \ref{entity_deviceCore} kodu klasy \texttt{DeviceCore} w linii 3 określono schemat dziedziczenia \mbox{TABLE\_PER\_CLASS}. O sposobie dziedziczenia napisano w podrozdziale \ref{dzedziczenie_hibernate:label}. Linia~3~określa strategie generowania klucza. Hibernate tworzy wtedy specjalną tabelę w bazie danych która odpowiedzialna jest za przechowywanie unikalnych kluczy głównych dla encji sprzętu w~aplikacji. W kodzie pokazanym na listingu \ref{entity_computer} nie trzeba wtedy definiować klucza.

\begin{lstlisting}[language=Java, style=JavaStyle, caption={Klasa nadrzędna reprezentująca rdzeń sprzętu: \texttt{DeviceCore}}, label={entity_deviceCore}]
@Entity
@Table(name = "device_core")
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class DeviceCore {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    @Column(name = "id", nullable = false)
    private Integer id;

    @Column(name = "device_type", length = 50)
    private String deviceType;

    @Column(name = "device_name", length = 50)
    private String deviceName;
		
		// Pozostała część klasy

\end{lstlisting}

Na listingu \ref{entity_computer} w linii 3 określone zostało dziedziczenie po klasie nadrzędnej reprezentującej rdzeń sprzętu. Pola które należy określić w tej klasie są unikalnymi polami tabeli \texttt{computer}. W linii 4 istnieje statyczna zmienna \texttt{DEVICE\_TYPE} która pomaga określić jakiego rodzaju dany sprzęt. Wykorzystywane jest to w aplikacji klienckiej.

\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa potomna: Computer, reprezentująca komputer}, label={entity_computer}]
@Entity
@Table(name = "computer")
public class Computer extends DeviceCore{

    public static final String DEVICE_TYPE = "COMPUTER";
    @Column(name = "serial_number", length = 50)
    private String serialNumber;

    @Column(name = "operating_system", length = 50)
    private String operatingSystem;

    @Column(name = "battery_life", length = 50)
    private String batteryLife;
		
		// Pozostała część klasy
\end{lstlisting}


\subsubsection{Przykład kodu repozytorium dla urządzeń dziedziczącym po rdzeniu sprzętu}
Repozytorium sprzętu komputerowego napisano z użyciem wyrażeń generycznych (patrz listing~\ref{repo_genericDevice}). Takie podejście przyczynia się do uproszczenia kodu oraz łatwiejszej jego rozbudowy.
\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Generyczne repozytorium sprzętu komputerowego:  GenericDeviceRepository}, label={repo_genericDevice}]
@NoRepositoryBean
public interface GenericDeviceRepository<T extends DeviceCore> extends JpaRepository<T, Integer> {
    
    List<T> findAllByReadyToLotteryIsTrue();
    List<T> findAllByOfficeId(int officeId);
}
\end{lstlisting}

Adnotacja \texttt{@NoRepositoryBean} z linii 1 jest używana do oznaczenia interfejsów, które nie mają mieć swojej instancji. Oznacza to, że nie jest on przeznaczony do utworzenia instancji repozytorium w trakcie uruchomiania aplikacji. W linii 4 i 5 poprzez zdefiniowanie metody możliwe jest wykonanie konkretnego zapytania SQL do bazy danych. Z racji, że klasy sprzętu komputerowego mają zbliżone funckie, nie trzeba dostarczać tych samych interfejsów we wszystkich repozytoriach, tylko zastosować schemat dziedziczenia.

\subsubsection{Fragmenty implementacji klasy kontrolerów sprzętu}
Kontrolery pełnią istotną funkcje w systemie. Umożliwiają one definiowanie zapytań REST które będą wysyłane do serwera. Wykorzystując abstrakcje oraz wyrażenia generyczne możliwe jest wykonanie niektórych zapytań bez konieczności ich implementacji w klasach potomnych. Zaimplementowane kontrolery bazują na klasie abstrakcyjnej pokazanej na listingu~\ref{controller_genericDevice}.

\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa nadrzędna kontrolera sprzętu: \texttt{GenericDeviceController}}, label={controller_genericDevice}]
public abstract class GenericDeviceController<T extends DeviceCore> {

    protected final GenericDeviceService<T> genericDeviceService;
    protected final GenericDeviceRepository<T> genericRepository;

    protected GenericDeviceController(GenericDeviceService<T> genericDeviceService, GenericDeviceRepository<T> genericRepository) {
        this.genericDeviceService = genericDeviceService;
        this.genericRepository = genericRepository;
    }

    @GetMapping("/{id}")
    @CrossOrigin(origins = "*")
    T getOneBasicDevice(@PathVariable int id){
        return genericDeviceService.getDeviceById(id);
    }

    @GetMapping("/all")
    @CrossOrigin(origins = "*")
    List<T> getAllBasicDevices(){
        return genericDeviceService.getAllDevices();
    }

    @GetMapping("/all-ready-to-lottery")
    @CrossOrigin(origins = "*")
    List<T> getAllReadyToLotteryDevice(){
        return genericDeviceService.getAllReadyToLotteryDevices();
    }
		
		// Pozostała część klasy
		
		@PutMapping("/set-ready-to-lottery/{id}")
    @CrossOrigin(origins = "*")
    public ResponseEntity<T> setReadyToLottery(@PathVariable int id){
        try{
            T updatedBasicDevice = genericDeviceService.setReadyToLottery(id);
            return new ResponseEntity<>(updatedBasicDevice, HttpStatus.OK);
        } catch (RuntimeException e){
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }
		
		// Pozostała część klasy
		
\end{lstlisting}


Klasa pokazana na listingu \ref{controller_device} nie posiada własnych metod. Umożliwia jednak wykonywanie ogólnych operacji dotyczących sprzętu. Możliwe jest między innymi pobranie informacji dotyczące sprzętu bez względu na jego typ co idealnie obrazuje test \ref{getByIdTest:label}.
\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa potomna reprezentująca ogólną postać sprzętu}, label={controller_device}]
@RestController
@RequestMapping("/devices")
public class DeviceCoreController extends GenericDeviceController<DeviceCore>{

    protected DeviceCoreController(DeviceCoreService deviceCoreService, GenericDeviceRepository<DeviceCore> genericRepository) {
        super(deviceCoreService, genericRepository);
    }
}
\end{lstlisting}



\subsubsection{Fragmenty implementacji klas serwisów sprzętu}
Serwisy są odpowiedzialne za warstwę logiki biznesowej systemu. Implementację ich klasy bazowej pokazano na listingu \ref{service_tablet}.
\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa nadrzędna serwisu sprzętu GenericDeviceService}, label={service_tablet}]

public abstract class GenericDeviceService<T extends DeviceCore> {

    protected final GenericDeviceRepository<T> genericDeviceRepository;
    protected final OfficeRepository officeRepository;

    public GenericDeviceService(GenericDeviceRepository<T> genericRepository, OfficeRepository officeRepository) {
        this.genericDeviceRepository = genericRepository;
        this.officeRepository = officeRepository;
    }

    public T getDeviceById(int id) {
        Optional<T> basicDeviceOptional = genericDeviceRepository.findById(id);
        return basicDeviceOptional.orElseThrow(()-> new RuntimeException("Device not found with id: " + id));
    }

    public List<T> getAllDevices() {
        return genericDeviceRepository.findAll();
    }
		// Pozostała część klasy

protected DeviceCore addDevice(Class<? extends DeviceCore> deviceClass, String deviceName, Double price, String description, Integer age, Boolean readyToSell, Integer officeId) {

        if(officeId == null){
            throw new RuntimeException("Office required");
        }
        Optional<Office> officeOptional = officeRepository.findById(officeId);
        Office office = officeOptional.orElseThrow(() -> new RuntimeException("Office not found with id: " + officeId));

        DeviceCore deviceCore;
        try {
            deviceCore = deviceClass.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            throw new RuntimeException("Error creating device", e);
        }

        deviceCore.setDeviceName(deviceName);
        deviceCore.setPrice(price);
        deviceCore.setDescription(description);
        deviceCore.setAge(age);
        deviceCore.setReadyToSell(readyToSell);
        deviceCore.setOffice(office);

        return deviceCore;
    }
		
		// Pozostała część klasy
\end{lstlisting}
W linii 12 widnieje metoda, która pozwala na pobranie sprzętu. W linii 17 natomiast jest możliwe pobranie wszystkich sprzętów. Odbywa się to przy pomocy sparametryzowanych typów danych \texttt{T}. Metoda zdefiniowana w linii 22 pozwala uprościć dodawanie sprzętu, implementując część logiki ustawiając parametry charakterystyczne dla rdzenia sprzętu. Jednak aby utworzyć odpowiedni typ niezbędne jest określenie jakiego typu będzie dodawane urządzenie. Dlatego w linii 22 metoda jako parametr przyjmuje \texttt{Class<? extends DeviceCore>}, który oznacza typ aplikacji. Tak zdefiniowana metoda może zostać użyta do dodania sprzętu w klasach potomnych co pokazano w listingu \ref{service_tablet}.

\begin{lstlisting}[language=Java, style=JavaStyle,  caption={Klasa potomna serwisu tabletu: TabletService }, label={service_tablet}]
@Service
public class TabletService extends GenericDeviceService<Tablet>{

    public TabletService(TabletRepository tabletRepository, OfficeRepository officeRepository){
        super(tabletRepository, officeRepository);
    }

    public Tablet addTablet(String deviceName, Double price, String description,
                            Integer age, String officeAddress,
                            String screenSize, String operatingSystem, String batteryLife){

        Tablet tablet = (Tablet) addDevice(Tablet.class, deviceName, price, description,
                                                                age, officeAddress);

        tablet.setScreenSize(screenSize);
        tablet.setOperatingSystem(operatingSystem);
        tablet.setDeviceType(Tablet.DEVICE_TYPE);
        tablet.setBatteryLife(batteryLife);

        return genericDeviceRepository.save(tablet);
    }
		// Pozostała część klasy
\end{lstlisting}

Serwis klasy \texttt{TabletService} dziedziczy i parametryzuje metody klasy \texttt{GenericDeviceService}. Wykorzystuje on w linii 13 metodę klasy nadrzędnej co uprasza implementacje metody dodającej sprzęt (linia 9).

\section {Aplikacja kliencka}
Aplikacja kliencka jest aplikacją internetową, dostarczającą przyjazny interfejs użytkownika. Napisano ją w języku JavaScript, z wykorzystaniem biblioteki React (tabela \ref{tab:zestawienie_narzędzi}). Istnieją zdefiniowane zapytania REST do aplikacji serwerowej. Wykorzystując te zapytania na widoku widocznym dla użytkownika zostają podjęte specjalne akcje, które ten widok aktualizują. Formularze pokazywane są w takiej formie, że po kliknięciu odpowiedniego przycisku ukazuje się formularz na danym widoku. Zestawienie widoków, ścieżek i roli pokazano w tabeli \ref{tab:zestawienie_widokow}.

\subsection{Struktura projektu}
Ogólna struktura projektu powstała na skutek wywołania komendy tworzącej aplikacje Reacta: \texttt{npx create-react-app frontend}. Następnie utworzono folder \texttt{components}, który w~sobie zawiera foldery przechowujące pliki JavaScript na podstawie pełnionych funkcji w projekcie. Foldery i odpowiadające im funkcje są następujące: 
\begin {itemize}
\item \texttt{\textbf{auth}} przechowuje pliki odpowiedzialne za obsługę i stylizacje widoków logowania i rejestracji:
	\begin{itemize}
	\item \texttt{Login.js} -- skrypt odpowiedzialny za widok i funkcjonalność logowania,
	\item \texttt{Register.js} -- skrypt odpowiedzialny za widok i funkcjonalność rejestracji,
	\item \texttt{Login.css} -- arkusz styli odpowiedzialny za stylizacje widoków logowania i rejestracji,
	\end{itemize}
\item \texttt{\textbf{bar}} przechowuje skrypty odpowiedzialne za paski nawigacyjne poszczególnych widoków:
	\begin{itemize}
	\item \texttt{AdminHomeBar.js} -- skrypt odpowiedzialny za pasek nawigacyjny na widoku domowym administratora: \texttt{Home.js},
	\item \texttt{ComputerComponentsBar.js} -- skrypt odpowiedzialny za pasek nawigacyjny dla widoku komponentów: \texttt{ComputerComponents.js},
	\item \texttt{ManageUserBar.js} -- skrypt odpowiedzialny za pasek nawigacyjny widoku zarządzania użytkownikami: \texttt{Users.js},
	\item \texttt{UserHomeBar.js} -- skrypt odpowiedzialny za pasek nawigacyjny na widoku domowym pracownika: \texttt{Home.js},
	\item \texttt{UserLotteryHistory} -- skrypt odpowiedzialny za pasek nawigacyjnym na widoku historii loterii użytkownika: \texttt{UserLotteryHistory.js},
	\item \texttt{UsersInLottery.js} -- skrypt odpowiedzialny za pasek nawigacyjny na widoku użytkowników biorących udział w loterii: \texttt{UsersInLottery.js},
	\end{itemize}
\item \texttt{\textbf{computer\_components}} przechowuje skrypty formularzy komponentów komputera które mogą dodawać lub modyfikować te komponenty:
	\begin{itemize}
	\item \texttt{CpuForm.js} -- formularz procesora,
	\item \texttt{RamForm.js} -- formularz pamięci RAM,
	\item \texttt{StorageForm.js} -- formularz pamięcu dyskowej,
	\end{itemize}
\item \texttt{\textbf{device\_form}} przechowuje skrypty oraz arkusz styli odpowiedzialne za logikę formularzy dodawania, modyfikacji urządzeń:
	\begin{itemize}
	\item \texttt{AddNewFormPopup.js} -- formularz umożliwiający wybór formularza który dodaje komputer, tablet, lub inne urządzenie
	\item \texttt{ComputerForm.js} -- formularz komputera
	\item \texttt{DeviceForm.css} -- arkusz styli odpowiedzialny za stylizacje formularzy
	\item \texttt{FormPopup.js} -- skrypt odpowiedzialny za logikę i wybór rodzaju formularza(dodawanie, modyfikacja, informacje) urządzenia.
	\item \texttt{OtherDeviceForm} -- formularz innego urządzenia
	\item \texttt{TabletForm.js} -- formularz tabletu
	\end{itemize}
\item \texttt{\textbf{view}} przechowuje w sobie skrypty oraz arkusz styli odpowiedzialne za widoki aplikacji:
	\begin{itemize}
	\item \texttt{ComputerComponets.js} -- widok dostępny tylko dla administratora. Zawiera w sobie informacje o komponentach komputera w postaci tabeli,
	\item \texttt{Home.css} -- arkusz styli odpowiedzialny za stylizacje widoków,
	\item \texttt{Home.js} -- widok strony domowej, ma w sobie dwa warianty: Administratora i Pracownika,
	\item \texttt{UserLotteryHistory.js} -- widok historii loterii użytkownika o zadanym ID. Dostępny dla pracownika i administratora,
	\item \texttt{Users.js} -- widok pracowników zarejestrowanych w systemie. Dostępny tylko dla administratora,
	\item \texttt{UsersInLottery} -- widok pracowników biorących udział w loterii danego sprzętu. Dostępny tylko dal administratora.
	\end{itemize}
\end{itemize}

Równolegle do folderu \texttt{components} w folderze \texttt{src} istnieją jeszcze dwa skrypty, które są niezbędne do funkcjonowania aplikacji.
\begin{itemize}
	\item \texttt{App.js} -- zawiera w sobie ścieżki url pod którymi dostępne są poszczególne widoki,
	\item \texttt{index.js} -- definiuje funkcję główną programu.
\end{itemize}

Strukturę projektu pokazano na rysunku \ref{frontend_struktura:label}.
\begin{table}[htb] \small
	\centering
\caption{Zestawienie ścieżek url dostępnych w aplikacji klienckiej}
\label{tab:zestawienie_widokow}
\begin{tabularx}{\linewidth}{|>{\footnotesize}l|X|>{\footnotesize}l|X|}
    \hline
    Ścieżka & Widok & Skrypt & Rola\\
    \hline \hline
    \url{/auth/login} & Logowanie &  \texttt{Login.js} & Przed nadaniem roli\\
    \hline
    \url{/auth/register} & Rejestracja & \texttt{Register.js} & Przed nadaniem roli\\
    \hline
    \url{/home} & Strona domowa z~tabelą sprzętów & \texttt{Home.js} & Administrator lub Pracownik\\
    \hline
    \url{/users} & Tabela pracowników & \texttt{Users.js} & Administrator\\
    \hline
		\url{/components} & Tabela komponentów komputera& \texttt{ComputerComponents.js} & Administrator\\
    \hline
		\url{/users-in-lottery} & Tabela użytkowników biorących udział w loterii& \texttt{UsersInLottery.js} & Administrator lub Pracownik\\
    \hline
		\url{/users-lottery-history} & Tabela zawierająca historię loteri & \texttt{UsersLotteryHistory.js} & Administatro lub Pracownik\\
    \hline
\end{tabularx}
\end{table}


\begin{figure}[htb]
  \centering
	\begin{tabular}{@{}lll@{}}
	a) & b) & c) \\
  \vtop{\vskip-2ex\hbox{\includegraphics[width=0.27\textwidth]{rys05/frontend/frontend.pdf}}} & 
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.3\textwidth]{rys05/frontend/auth.pdf}}} &
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.3\textwidth]{rys05/frontend/bar.pdf}}} \\

	d) & e) & f) \\
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.3\textwidth]{rys05/frontend/components.pdf}}} &
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.3\textwidth]{rys05/frontend/deviceform.pdf}}} &
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.3\textwidth]{rys05/frontend/view.pdf}}}
	\end{tabular}
  \caption{Struktura projektu: a) ogólna struktura, b) Logowanie i rejestracja, c) pasek nawigacyjny, d) formularze komponentów, e) formularze sprzętów, f) widoki stron}
  \label{frontend_struktura:label}
\end{figure}


\subsection{Fragmenty implementacji}
	\subsubsection{Ścieżki url dla widoków aplikacji}
	Na listing kodu \ref{app_frontend:label} pokazano definicje ścieżek url, pod którymi dostępne są poszczególne widoki wymienione w tabeli~\ref{tab:zestawienie_widokow}.
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle,  caption={Zdefiniowane ścieżki url widoków systemu }, label={app_frontend:label}]
	const App = () => {
    return (
        <Router>
            <Routes>
                <Route path="/auth/login" element={<Login />} />
                <Route path="/auth/register" element={<Register />} />
                <Route path="/home" element={<Home />} />
                <Route path="/" element={<Navigate to="/auth/login" />} />
                <Route path="/auth/*" element={<Navigate to="/auth/login" />} />
                <Route path="/users" element={<Users/>}/>
                <Route path="/components" element={<ComputerComponents/>}/>
                <Route path="/users-in-lottery" element={<UsersInLottery/>}/>
                <Route path="/user-lottery-history" element={<UserLotteryHistory/>}/>
            </Routes>
        </Router>
\end{lstlisting}


\subsubsection{Sparametryzowany formularz urządzenia}
Kod skryptu \texttt{FormPopup.js} przedstawiony na listingu \ref{render_data:label} służy do wyboru formularza na podstawie typu sprzętu oraz operacji wykonywanej przez formularz. Przyjmuje 4 argumenty. Przekazywanie tych parametrów odbywa się w linii 4 z wykorzystaniem "`\texttt{props}"'. Zmienna \texttt{deviceType} odpowiada dla jakiego urządzenia dotyczy formularz. Może on dotyczyć komputera, tabletu lub innego urządzenia co pokazano w liniach 9-11. Zmienna \texttt{setTrigger} jest odpowiedzialna za to czy formularz jest aktualnie wyświetlany na widoku. Zmienna \texttt{formType} dotyczy operacji reprezentowanej przez formularz. Istnieją 3 operacje: dodawania nowego sprzętu, modyfikacji sprzętu oraz wyświetlania informacji o sprzęcie. Tak stworzona funkcja umożliwia zarządzanie formularzami które zostały zdefiniowane w~skryptach \texttt{ComputerForm.js}, \texttt{TabletForm.js} oraz \texttt{OtherDeviceForm.js}.
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle,  caption={Obsługa formularzy}, label={render_data:label}]
function FormPopup(props){
    
 const {setTrigger, formType, deviceType, deviceId} = props;
    
  return (props.trigger) ? (
    <div className="popup">
      <div>
         {deviceType === 'COMPUTER' && <ComputerForm setTrigger={props.setTrigger} formType={formType} deviceId={deviceId}/>}
         {deviceType === 'TABLET' && <TabletForm setTrigger={props.setTrigger} formType={formType} deviceId={deviceId}/>}
         {deviceType === 'OTHER' && <OtherDeviceForm setTrigger={props.setTrigger}  formType={formType} deviceId={deviceId} />}
         {props.children}
      </div>
    </div>
 ) : "";
\end{lstlisting}


Na listingu \ref{addComputer:label} ukazano, w jaki sposób aplikacje kliencka komunikuje się z serwerem. Po podaniu odpowiednich danych w formularzu i kliknięciu przycisku następuje wysłanie żądania typu POST do serwera które dodaje nowy komputer. 
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle,  caption={Przykładowe zapytanie do serwera dla formularza komputera}, label={addComputer:label}]
const handleAddComputer = async (e) =>{
    try{
        const compData ={
            "deviceName" : formData.deviceName,
            "price" : formData.price,
            "description" : formData.description,
            "age" : formData.age,
            "officeAddress" : formData.office,
            "serialNumber" : formData.serialNumber,
            "model" : formData.model,
            "operatingSystem" : formData.model,
            "batteryLife" : formData.batteryLife,
            "cpuName" : formData.cpu,
            "storageName" : formData.storage,
            "ramName" : formData.ram};
     const response = await axios.post('http://localhost:8080/computers/add', compData, {});
        }catch (error){console.error('Bład dodawania komputera', error)}}
\end{lstlisting}

\subsection{Instrukcja użytkowania}
Zdefiniowano widoki aplikacji i pogrupowano je ze względu na typ które pełnią.
\begin{itemize}
	\item W-1 -- widok logowania i rejestracji (rysunek \ref{authview:label}),
	\item W-2 -- widok strony domowej zawierający urządzenia oraz loterię tych urządzeń (rysunek \ref{home:label}),
	\item W-3 -- widok formularzy dodawania urządzeń, z wariantami na podstawie typu urządzenia (rysunek \ref{formsAdd:label}),
	\item W-4 -- widok formularzy modyfikacji urządzeń (rysunek \ref{formsMod:label}),
	\item W-5 -- widok formularzy informacji urządzeń (rysunek \ref{formsInfo:label}),
	\item W-6 -- widok użytkowników i uczestników (rysunek \ref{manageUsers:label}),
	\item W-7 -- widok historii loterii użytkownika (rysunek \ref{lotteryHistory:label}),
	\item W-8 -- widok komponentów komputera (rysunek \ref{components:label}),
	\item W-9 -- widok formularzy komponentów komputera (rysunek \ref{compforms:label}).
\end{itemize} 

\begin{figure}[H]
  \centering
	\begin{tabular}{@{}ll@{}}
	a) & b) \\
  \vtop{\vskip-2ex\hbox{\includegraphics[width=0.29\textwidth]{rys05/view/login.pdf}}} & 
	\vtop{\vskip-2ex\hbox{\includegraphics[width=0.29\textwidth]{rys05/view/register.pdf}}}
	\end{tabular}
  \caption{Widok W-1, Logowanie i Rejestracja: a) logowanie, b) rejestracja}
  \label{authview:label}
\end{figure}

\newpage
Początkowym widokiem aplikacji jest widok z widok W-1 z formularzem logowania i rejestracji. Każdy użytkownik musi się zalogować podając poprawne dane logowania (rysunek \ref{authview:label}a). W przypadku braku konta możliwa jest rejestracja, klikając na odnośnik "`Nie masz konta? Zarejestruj się"'. Po kliknięciu odnośnika następuje przekierowanie na formularz rejestracji (rysunek \ref{authview:label}b). Po pomyślnym zarejestrowaniu następuje przekierowanie do formularza logowania. Możliwe jest też kliknięcie odnośnika "`Masz już konto? Zaloguj się"' aby przejść do formularza logowania.
\begin{figure}[H]
  \centering
	\begin{tabular}{@{}lll@{}}
	a)\\
  \includegraphics[width=\textwidth]{rys05/view/alldevices.pdf} \\
	
	b)\\
	\includegraphics[width=\textwidth]{rys05/view/compGrun.pdf} \\
	c) \\
	\includegraphics[width=\textwidth]{rys05/view/pracownikHome.pdf}
	\end{tabular}
  \caption{Widok W-2, Strona domowa: a) Administrator bez filtrowania, b) Administrator z~filtrowaniem, c) Pracownik bez filtrowania}
  \label{home:label}
\end{figure}

Na rysunku \ref{home:label} pokazano wariantowy widok W-2 z tabelą urządzeń z loteriami. Dla każdego wariantu istnieje przycisk wyloguj odpowiedzialny za wylogowywanie i przekierowanie do widoku W-1a (rysunek~\ref{authview:label}). Na widoku W-2 możliwe jest filtrowanie urządzeń po typie urządzenia oraz po biurze, w którym się znajdują. Dla wariantu W-2b pokazane zostały tylko komputery, które znajdują się w~biurze Grunwaldzka. 

Wyświetlanie szczegółowych informacji o urządzeniu odbywa się na widoku formularzy W-5 pokazanym na rysunku \ref{formsInfo:label}. Wybierany jest odpowiedni formularz W-5a, W-5b, W-5c na podstawie typu urządzenia.

% TO DO: proszę sprawdzić opis. Próbowałem go uporządkować, ale nie skończyłem. Kłopot polega na tym, że są numery rysunków (np. rys.5.5), numery widoków (np. W-3), a także etykiety przypisane do wariantów (W-3a). Czasem to się nie klei - rys.5.5 ma części a, b, c,  które są formularzami wariantowymi oraz częśći d, e , które nie są formularzami wariantwymi (właściwie to powinny być widoki umieszczone na osobnym rysunku - jeden (d) to formularz do edycji, drugi (e) to strona informacyjna).
% DONE dodałem dwa widoki W-4(modyfikacji) W-5(informacji) z rysunkami dotyczącymi komputera, tabletu i innego urządzenia. 

Widok W-2 jest widokiem administratora, oferującym wiele funkcji:
\begin{itemize}
	\item Kliknięcie przycisku "`Dodaj urządzenie"' sprawia, że na ekranie wyświetlany jest formularz W-3. Początkowo wyśiwetlany jest wariant W-3a ale istniej możliwość na zmianę typu formularza na wariant  W-3b lub W-3c poprzez odpowiedni wybór z listy rozwijanej,
	\item kliknięcie przycisku "`Przeglądaj komponenty"' sprawia, że następuje przekierowanie do widoku komponentów W-8,
	\item kliknięcie przycisku "`Zarządzaj użytkownikami"' przekierowuje do widoku zarejestrowanych pracowników W-6a (rysunek \ref{manageUsers:label}),
	\item kliknięcie przycisku "`Zmień"' w kolumnie czy sprzedany ustawia status sprzętu na sprzedany lub nie. Jest to informacja czy sprzęt został dostarczony do pracownika,
	\item kliknięcie przycisku w kolumnie "`Gotowy na losowanie"' możliwe jest tylko wtedy gdy losowanie się nie odbyło. Sprawia ono, że operacja "`Losuj"' w kolumnie loteria jest możliwa. Sprzęty które mają status gotowe do losowania są wyświetlane na widoku pracownika W-2c,
	\item kliknięcie przycisku "`Usuń"' usuwa z systemu odpowiedni sprzęt,
	\item kliknięcie przycisku "`Modyfikuj"' wyświetla widok formularza modyfikacji W-4 (rysunek \ref{formsMod:label}). Wyśiwtlany jest jeden z formularzy W-4a, W-4b, W-4c na podstawie typu modyfikowanego urządzenia,
	\item kliknięcie przycisku "`Wyświetl"' w kolumnie "`Lista uczestników"' przekierowuje do widoku pracowników biorących udział w loterii wybranego sprzętu W-6b (rysunek \ref{manageUsers:label}),
	\item kliknięcie przycisku "`Losuj"' w kolumnie loteria możliwe jest w przypadku gdy urządzenie jest gotowe do losowania oraz loteria się jeszcze nie odbyła. Następnie po kliknięciu przycisku ustawiana data losowania jest na dzisiejszą oraz losowany jest zwycięzca losowania. W~przypadku braku uczestników losowanie nie odbędzie się,
\end{itemize}
Widok W-2c (rysunek~\ref{home:label}) jest widokiem pracownika. Nie posiada on tak zaawansowanych funkcjonalności jak administrator, 
\begin{itemize}
	\item kliknięcie przycisku w kolumnie loteria umożliwia zapisywanie lub wypisywanie z uczestnictwa w losowaniu. Zapis na loterie możliwy jest wtedy kiedy losowanie się jeszcze nie odbyło,
	\item kliknięcie przycisku "`Przeglądaj swoje loterie"' przekierowuje do widoku W-7 (rysunek \ref{lotteryHistory:label}). Widok ten posiada historię loterii dla aktualnie zalogowanego użytkownika.
\end{itemize}


\begin{figure}[H]
  \centering
	\begin{tabular}{@{}l@{~}l@{~}l@{}}
	a) & b) & c) \\
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/addComputer.pdf}}}} &
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/addTablet.pdf}}}} & 
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/addOther.pdf}}}} 
	
	\end{tabular}
  \caption{Widok W-3 dodawania urządzenia a) wariant komputera: b) wariant tabletu, c) wariant innego urządzenia}
  \label{formsAdd:label}
\end{figure}


Formularze W-3 ukazane na rysunku \ref{formsAdd:label} są dostępne tylko dla administratora. Wyświetlane są jako wyskakujące okno. Początkowym wariantem jest wariant W-3a służący za dodawanie komputera. Wariant można zmienić na dodawanie tabletu W-3b lub dodawanie innego urządzenia W-3c po przez wybór opcji z listy rozwijanej na formularzu. Na wariancie W-3a istnieje możliwość dodawania procesora, pamięci RAM i pamięci dyskowej po przez kliknięcie przycisku. Każdy przycisk powoduje otworzenie odpowiedniego formularza z widoku W-9. Ważnym aspektem takiego rozwiązania jest to, że jeżeli użytkownik nie znajdzie odpowiedniego: procesora, RAM lub dysku to może szybko je dodać. Po takim dodaniu następuje powrót do formularza, formularz zachowuje poprzedni stan, a lista rozwijana dotycząca dodawanego komponentu od razu zostaje uzupełniona o dodatkowe dane. Podobną funkcjonalność ma widok W-4a modyfikacji komputera \ref{formsMod:label}. 


\begin{figure}[H]
  \centering
	\begin{tabular}{@{}l@{~}l@{~}l@{}}
	a) & b) & c) \\
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/modComputer.pdf}}}} &
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/modTablet.pdf}}}} & 
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/modOther.pdf}}}}
	
	\end{tabular}
  \caption{Widok W-4 formularzy modyfikacji: a) komputera: b) tabletu, c) innego urządzenia}
  \label{formsMod:label}
\end{figure}

Formularze na widoku W-4 (rysunek \ref{formsMod:label}) są bardzo podobne do tych na widoku W-3 przedstawionych na rysunku\ref{formsAdd:label}.  Zasadniczą różnicą jest jednak to, że przy modyfikacji urządzenia od razu określony jest jego typ, przez co nie ma możliwości zmiany na formularza na inny typ, tak jak to było możliwe przez listę rozwijaną w widoku W-3. Drugim aspektem jest to, że formularze są już wypełnione o odpowiednie dane które zawiera modyfikowane urządzenie. Wymazanie takich danych sprawi to, że odpowiednie pola będą miały wartość \texttt{null}. W formularzu W-4a możliwe jest też dodanie odpowiedniego komponentu na podstawie jednego z trzech przycisku co działa w ten sam sposób jak formularzu W-3a \ref{formsAdd:label}. Formularze te również dostępne są tylko z poziomu administratora.


\begin{figure}[H]
  \centering
	\begin{tabular}{@{}l@{~}l@{~}l@{}}
	a) & b) & c) \\
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/infoComputer.pdf}}}} &
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/infoTablet.pdf}}}} &
	\vtop{\vskip-2ex\hbox{\fbox{\includegraphics[width=0.3\linewidth]{rys05/view/infoOther.pdf}}}} 
	
	\end{tabular}
  \caption{Widok W-5 formularzy informacji: a) o komputerze, b) o tablecie, c) o innym sprzęcie}
  \label{formsInfo:label}
\end{figure}

Formularze na widoku W-5 (rysunek \ref{formsInfo:label}) podobne są do tych z widoków W-3 (rysunek \ref{formsAdd:label}) i W-4 (rysunek(\ref{formsMod:label}). Jednak w przeciwieństwie do nich nie dodają ani modyfikują danych. Z formularzy tych może korzystać również pracownik. Dane na takim formularzu są od razu uzupełnione i zablokowane. 

\begin{figure}[H]
  \centering
	\begin{tabular}{@{}lll@{}}
	a)\\
  \includegraphics[width=\textwidth]{rys05/view/manageUsers.pdf} \\
	
	b)\\
	\includegraphics[width=\textwidth]{rys05/view/participation.pdf} \\
	
	\end{tabular}
  \caption{Widok W-6, Informacje o użytkownikach: a) Zarządzanie użytkownikami przez administratora, b) Przeglądanie uczestników losowania}
  \label{manageUsers:label}
\end{figure}


Widok W-6 (rysunek \ref{manageUsers:label}) posiada informacje o użytkownikach. W-6a jest widokiem dostępnym tylko dla administratora
\begin{itemize}
	\item kliknięcie przycisku powrót do urządzeń przekierowuje do strony domowej W-2 (rysunek \ref{home:label}),
	\item kliknięcie przycisku "`Pokaż historię"' w kolumnie Historia loterii przekierowuje do widoku historii loterii  W-7 (rysunek \ref{lotteryHistory:label}) dla odpowiadającego pracownika,
	\item kliknięcie przycisku "`Usuń użytkownika"' usuwa z systemu użytkownika.
\end{itemize}
Widok W-6b też jest widokiem tylko dostępnym dla administratora. Posiada on listę uczestników oraz informacje o wygranej przegranej każdego poszczególnego uczestnika dla wybranej loterii.


\begin{figure}[H]
		\centering
    \includegraphics[width=\linewidth]{rys05/view/lotteryHistory.pdf}
    \caption{Widok W-7, Historia loteri pracownika}
    \label{lotteryHistory:label}
\end{figure}


Widok W-7 pozwala wyświetlić historię loterii użytkownika (rysunek \ref{lotteryHistory:label}). Pozwala on na pracownikowi przeglądanie własnej historii. Administrator może skorzystać z tego widoku aby sprawdzić historię loterii wybranego pracownika.
\begin {itemize}
	\item możliwe jest tutaj filtrowanie loterii na podstawie statusu uczestnika. Są dostępne 3 opcje: "`Wszystkie loterie użytkownika"', "`Wygrana"' i "`Trwająca"',
	\item kliknięcie przycisku "`Informacje"' wyświetla formularz informacji z rysunku \ref{formsInfo:label} na podstawie typu sprzętu.
	\item kliknięcie przycisku "`Wypisz się"' możliwe jest wtedy kiedy loteria się jeszcze nie odbyła. Po kliknięciu tego przycisku pracownik rezygnuje z uczestnictwa w losowaniu wybranego sprzętu.
\end{itemize} 


\begin{figure}[H]
		\centering
    \includegraphics[width=\linewidth]{rys05/view/components.pdf}
    \caption{Widok W-8, Widok komponentów komputera}
    \label{components:label}
\end{figure}

Widok W-8 jest dostępny dla administratora. Pozwala mu na oszacowanie ceny sprzętu patrząc jakie komponenty mają cenę. Możliwe jest wybranie z listy rozwijanej jakiego rodzaju komponenty mają być wyświetlane. Do wyboru są: procesory, pamięci RAM oraz pamięci dyskowe.
\begin{itemize}
	\item kliknięcie przycisku "`Dodaj procesor"' wyświetli formularz W-9a (rysunek \ref{compforms:label}a) odpowiedzialny za dodanie procesora,
	\item kliknięcie przycisku "`Dodaj RAM"' Wyświetli formularz W-9b (rysunek \ref{compforms:label}b) odpowiedzialny za dodanie pamięci RAM,
	\item kliknięcie przycisku "`Dodaj dysk"' Wyświetli formularz W-9c (rysunek \ref{compforms:label}c) odpowiedzialny za dodawanie dysku pamięci,
	\item kliknięcie przycisku "`Zarządzaj użytkownikami"' przekieruje do widoku W-6a (rysunek \ref{manageUsers:label}),
	\item klikniecie przycisku usuń spowoduje usunięcie komponentu. Komputer posiadający usuwany komponent ustawia identyfikator odpowiedniego komponentu na wartość "`\texttt{null}"'.
\end{itemize} 

W przypadku dodaniu komponentu, którego nazwa już istnieje następuje modyfikacja ceny.
% TO DO - rysunki się nie mieszczą na stronie!!!
% chyba DONE, pozmieniałem żeby rysunki mieściły się na stronach, czyli opisy były przy rysunkach. Czasem rysunek jest na końcu jednej strony a opis na początku drugiej, ale nie wiem czy tak może być.

\begin{figure}[H]
  \centering
	\begin{tabular}{@{}lll@{}}
	a) & b) & c) \\
  \includegraphics[width=0.31\textwidth]{rys05/view/addProc.pdf} & 
	\includegraphics[width=0.31\textwidth]{rys05/view/addRam.pdf} &
	\includegraphics[width=0.31\textwidth]{rys05/view/addStorage.pdf}
	\end{tabular}
  \caption{Widok W-9, Formularze komponentów: a) procesor, b) ram, c) dysk pamięci}
  \label{compforms:label}
\end{figure}

Widok W-9 (rysunek \ref{compforms:label}) odpowiada za prezentację formularzy komponentów. Formularze te mogą zostać wyświetlone po kliknięciu odpowiedniego przycisku na widoku W-8 (rysunek \ref{components:label}) lub z przycisku dostępnego na formularzach dodawania i modyfikacji komputera (rysunek \ref{formsAdd:label}a i \ref{formsMod:label}a)



